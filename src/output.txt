[[syntax trees at end of                    parser]] // Methods.scala
package <empty> {
  class Methods extends scala.AnyRef {
    def <init>() = {
      super.<init>();
      ()
    };
    def sum(a: Int) = a.$times(2);
    def foo: Unit = {
      val xs = List(1, 2, 3);
      xs.map(sum)
    }
  }
}

[[syntax trees at end of                     namer]] // Methods.scala: tree is unchanged since parser
[[syntax trees at end of            packageobjects]] // Methods.scala: tree is unchanged since parser
[[syntax trees at end of                     typer]] // Methods.scala
package <empty> {
  class Methods extends scala.AnyRef {
    def <init>(): Methods = {
      Methods.super.<init>();
      ()
    };
    def sum(a: Int): Int = a.*(2);
    def foo: Unit = {
      val xs: List[Int] = immutable.this.List.apply[Int](1, 2, 3);
      {
        xs.map[Int, Any]({
          ((a: Int) => Methods.this.sum(a))
        })(immutable.this.List.canBuildFrom[Int]);
        ()
      }
    }
  }
}

[[syntax trees at end of                    patmat]] // Methods.scala: tree is unchanged since typer
[[syntax trees at end of            superaccessors]] // Methods.scala: tree is unchanged since typer
[[syntax trees at end of                extmethods]] // Methods.scala: tree is unchanged since typer
[[syntax trees at end of                   pickler]] // Methods.scala: tree is unchanged since typer
[[syntax trees at end of                 refchecks]] // Methods.scala: tree is unchanged since typer
[[syntax trees at end of                   uncurry]] // Methods.scala
package <empty> {
  class Methods extends Object {
    def <init>(): Methods = {
      Methods.super.<init>();
      ()
    };
    def sum(a: Int): Int = a.*(2);
    def foo(): Unit = {
      val xs: List[Int] = immutable.this.List.apply[Int](scala.this.Predef.wrapIntArray(Array[Int]{1, 2, 3}));
      {
        xs.map[Int, Any]({
          {
            @SerialVersionUID(value = 0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1[Int,Int] with Serializable {
              def <init>(): <$anon: Int => Int> = {
                $anonfun.super.<init>();
                ()
              };
              final def apply(a: Int): Int = Methods.this.sum(a)
            };
            (new <$anon: Int => Int>(): Int => Int)
          }
        }, immutable.this.List.canBuildFrom[Int]());
        ()
      }
    }
  }
}

[[syntax trees at end of                 tailcalls]] // Methods.scala: tree is unchanged since uncurry
[[syntax trees at end of                specialize]] // Methods.scala
package <empty> {
  class Methods extends Object {
    def <init>(): Methods = {
      Methods.super.<init>();
      ()
    };
    def sum(a: Int): Int = a.*(2);
    def foo(): Unit = {
      val xs: List[Int] = immutable.this.List.apply[Int](scala.this.Predef.wrapIntArray(Array[Int]{1, 2, 3}));
      {
        xs.map[Int, Any]({
          {
            @SerialVersionUID(value = 0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1$mcII$sp with Serializable {
              def <init>(): <$anon: Int => Int> = {
                $anonfun.super.<init>();
                ()
              };
              final def apply(a: Int): Int = $anonfun.this.apply$mcII$sp(a);
              <specialized> def apply$mcII$sp(a: Int): Int = Methods.this.sum(a)
            };
            (new <$anon: Int => Int>(): Int => Int)
          }
        }, immutable.this.List.canBuildFrom[Int]());
        ()
      }
    }
  }
}

[[syntax trees at end of             explicitouter]] // Methods.scala
package <empty> {
  class Methods extends Object {
    def <init>(): Methods = {
      Methods.super.<init>();
      ()
    };
    def sum(a: Int): Int = a.*(2);
    def foo(): Unit = {
      val xs: List[Int] = immutable.this.List.apply[Int](scala.this.Predef.wrapIntArray(Array[Int]{1, 2, 3}));
      {
        xs.map[Int, Any]({
          {
            @SerialVersionUID(value = 0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1$mcII$sp with Serializable {
              def <init>($outer: Methods.this.type): <$anon: Int => Int> = {
                $anonfun.super.<init>();
                ()
              };
              final def apply(a: Int): Int = $anonfun.this.apply$mcII$sp(a);
              <specialized> def apply$mcII$sp(a: Int): Int = $anonfun.this.$outer.sum(a);
              <synthetic> <paramaccessor> <artifact> private[this] val $outer: Methods.this.type = _;
              <synthetic> <stable> <artifact> def $outer(): Methods.this.type = $anonfun.this.$outer
            };
            (new <$anon: Int => Int>(Methods.this): Int => Int)
          }
        }, immutable.this.List.canBuildFrom[Int]());
        ()
      }
    }
  }
}

[[syntax trees at end of                   erasure]] // Methods.scala
package <empty> {
  class Methods extends Object {
    def <init>(): Methods = {
      Methods.super.<init>();
      ()
    };
    def sum(a: Int): Int = a.*(2);
    def foo(): Unit = {
      val xs: List = immutable.this.List.apply(scala.this.Predef.wrapIntArray(Array[Int]{1, 2, 3}));
      {
        xs.map({
          {
            @SerialVersionUID(value = 0) final <synthetic> class $anonfun extends scala.runtime.AbstractFunction1$mcII$sp with Serializable {
              def <init>($outer: Methods): <$anon: Function1> = {
                $anonfun.super.<init>();
                ()
              };
              final def apply(a: Int): Int = $anonfun.this.apply$mcII$sp(a);
              <specialized> def apply$mcII$sp(a: Int): Int = $anonfun.this.$outer.sum(a);
              <synthetic> <paramaccessor> <artifact> private[this] val $outer: Methods = _;
              <synthetic> <stable> <artifact> def $outer(): Methods = $anonfun.this.$outer;
              final <bridge> <artifact> def apply(v1: Object): Object = scala.Int.box($anonfun.this.apply(unbox(v1)))
            };
            (new <$anon: Function1>(Methods.this): Function1)
          }
        }, immutable.this.List.canBuildFrom());
        ()
      }
    }
  }
}

[[syntax trees at end of               posterasure]] // Methods.scala: tree is unchanged since erasure
[[syntax trees at end of                  lazyvals]] // Methods.scala: tree is unchanged since erasure
[[syntax trees at end of                lambdalift]] // Methods.scala
package <empty> {
  class Methods extends Object {
    def <init>(): Methods = {
      Methods.super.<init>();
      ()
    };
    def sum(a: Int): Int = a.*(2);
    def foo(): Unit = {
      val xs: List = immutable.this.List.apply(scala.this.Predef.wrapIntArray(Array[Int]{1, 2, 3}));
      {
        xs.map({
          {
            (new <$anon: Function1>(Methods.this): Function1)
          }
        }, immutable.this.List.canBuildFrom());
        ()
      }
    };
    @SerialVersionUID(value = 0) final <synthetic> class $anonfun$foo$1 extends scala.runtime.AbstractFunction1$mcII$sp with Serializable {
      def <init>($outer: Methods): <$anon: Function1> = {
        $anonfun$foo$1.super.<init>();
        ()
      };
      final def apply(a: Int): Int = $anonfun$foo$1.this.apply$mcII$sp(a);
      <specialized> def apply$mcII$sp(a: Int): Int = $anonfun$foo$1.this.$outer.sum(a);
      <synthetic> <paramaccessor> <artifact> private[this] val $outer: Methods = _;
      <synthetic> <stable> <artifact> def $outer(): Methods = $anonfun$foo$1.this.$outer;
      final <bridge> <artifact> def apply(v1: Object): Object = scala.Int.box($anonfun$foo$1.this.apply(scala.Int.unbox(v1)))
    }
  }
}

[[syntax trees at end of              constructors]] // Methods.scala
package <empty> {
  class Methods extends Object {
    def sum(a: Int): Int = a.*(2);
    def foo(): Unit = {
      val xs: List = immutable.this.List.apply(scala.this.Predef.wrapIntArray(Array[Int]{1, 2, 3}));
      {
        xs.map({
          {
            (new <$anon: Function1>(Methods.this): Function1)
          }
        }, immutable.this.List.canBuildFrom());
        ()
      }
    };
    @SerialVersionUID(value = 0) final <synthetic> class $anonfun$foo$1 extends scala.runtime.AbstractFunction1$mcII$sp with Serializable {
      final def apply(a: Int): Int = $anonfun$foo$1.this.apply$mcII$sp(a);
      <specialized> def apply$mcII$sp(a: Int): Int = $anonfun$foo$1.this.$outer.sum(a);
      <synthetic> <paramaccessor> <artifact> private[this] val $outer: Methods = _;
      final <bridge> <artifact> def apply(v1: Object): Object = scala.Int.box($anonfun$foo$1.this.apply(scala.Int.unbox(v1)));
      def <init>($outer: Methods): <$anon: Function1> = {
        if ($outer.eq(null))
          throw null
        else
          $anonfun$foo$1.this.$outer = $outer;
        $anonfun$foo$1.super.<init>();
        ()
      }
    };
    def <init>(): Methods = {
      Methods.super.<init>();
      ()
    }
  }
}

[[syntax trees at end of                   flatten]] // Methods.scala
package <empty> {
  class Methods extends Object {
    def sum(a: Int): Int = a.*(2);
    def foo(): Unit = {
      val xs: List = immutable.this.List.apply(scala.this.Predef.wrapIntArray(Array[Int]{1, 2, 3}));
      {
        xs.map({
          {
            (new <$anon: Function1>(Methods.this): Function1)
          }
        }, immutable.this.List.canBuildFrom());
        ()
      }
    };
    def <init>(): Methods = {
      Methods.super.<init>();
      ()
    }
  };
  @SerialVersionUID(value = 0) final <synthetic> class anonfun$foo$1 extends scala.runtime.AbstractFunction1$mcII$sp with Serializable {
    final def apply(a: Int): Int = anonfun$foo$1.this.apply$mcII$sp(a);
    <specialized> def apply$mcII$sp(a: Int): Int = anonfun$foo$1.this.$outer.sum(a);
    <synthetic> <paramaccessor> <artifact> private[this] val $outer: Methods = _;
    final <bridge> <artifact> def apply(v1: Object): Object = scala.Int.box(anonfun$foo$1.this.apply(scala.Int.unbox(v1)));
    def <init>($outer: Methods): <$anon: Function1> = {
      if ($outer.eq(null))
        throw null
      else
        anonfun$foo$1.this.$outer = $outer;
      anonfun$foo$1.super.<init>();
      ()
    }
  }
}

[[syntax trees at end of                     mixin]] // Methods.scala: tree is unchanged since flatten
[[syntax trees at end of                   cleanup]] // Methods.scala: tree is unchanged since flatten
[[syntax trees at end of                delambdafy]] // Methods.scala: tree is unchanged since flatten
[[syntax trees at end of                     icode]] // Methods.scala: tree is unchanged since flatten
[[syntax trees at end of                       jvm]] // Methods.scala: tree is unchanged since flatten
